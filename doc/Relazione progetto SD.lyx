#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{multicol}
\end_preamble
\use_default_options false
\begin_modules
minimalistic
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding default
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement b
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 0
\use_esint 0
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\bullet 1 0 10 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\lang italian
Progetto di sistemi distribuiti
\begin_inset Newline newline
\end_inset


\begin_inset Quotes eld
\end_inset

Almost-Othello
\begin_inset Quotes erd
\end_inset

 multiplayer
\end_layout

\begin_layout Author

\lang italian
di G.
 Benvenuti, G.
 Ledonne, L.
 Leoni
\begin_inset Newline newline
\end_inset

{benvenut | ledonne | lleoni} @ cs.unibo.it
\end_layout

\begin_layout Standard
Questo documento e' la relazione del progetto ed e' composto sostanzialmente
 da tre parti: introduzione al gioco e spiegazione dettagliata delle regole,
 scelte effettuate in fase di progettazione - p.e.
 stato dei giocatori, informazioni condivise, gestione dei guasti - e strategie
 implementative - strutturazione delle classi e librerie utilizzate.
 A queste se ne aggiunge una dedicata a class e sequence diagram UML.
 Il gioco che e' stato scelto e' la versione multiplayer dell'antico Reversi
 (gioco per due giocatori), leggermente riadattato per rendere quanto possibile
 paritaria la coesistenza di piu' di due giocatori.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{multicols}{2}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{multicols}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
1.
 Introduzione
\end_layout

\begin_layout Standard
Si vuole sviluppare multiplayer distribuito con 
\begin_inset Formula $N\geq3$
\end_inset

 giocatori, tutti pari fra loro, che condividono uno stato globale condiviso
 rappresentato da una othelliera
\begin_inset Foot
status open

\begin_layout Plain Layout
Tale definizione e' quella riconosciuta all'interno del regolamento ufficiale
 del gioco
\end_layout

\end_inset

.
 Riguardo alle specifiche imposte il sistema tollerera' 
\begin_inset Formula $N-1$
\end_inset

 guasti di tipo crash, si potra' contare su canali di comunicazine affidabili,
 e verra' utilizzato RMI, e non i socket, per la comunicazione fra i nodi.
 L'unica componente centralizzata sara' la registrazione iniziale al gioco,
 che a partita iniziata non sara' piu' necessaria.
\end_layout

\begin_layout Subsection*
2.
 Regole del gioco
\end_layout

\begin_layout Standard
Come accennato in precedenza, il gioco che e' stato scelto si ispira molto
 a Othello, un classico per due giocatori.
\end_layout

\begin_layout Standard
Da regolamento Othello non e' giocabile da un numero di giocatori diverso
 da due, quindi si e' deciso di modificarlo applicando il seguente pacchetto
 di regole:
\end_layout

\begin_layout Itemize
Disposizione iniziale random delle pedine, tre per giocatore;
\end_layout

\begin_layout Itemize
Pedine dentificate da colori diversi;
\end_layout

\begin_layout Itemize
Ogni pedina ha a disposizione due tipi di mosse: conquista e colonizza:
\end_layout

\begin_deeper
\begin_layout Itemize
Conquista (
\begin_inset Formula $c_{1}$
\end_inset

) consiste nel porre una pedina del proprio colore in uno degli spazi vuoti
 in modo che una o piu' pedine di uno o piu' avversari, situate perpendicolarmen
te, orizzontalmente, e/o diagonalmente, rimangano chiuse tra quest'ultima
 ed un'altra preesistente del proprio colore.
 Non devono essere presenti pedine vuote in mezzo al percorso 
\end_layout

\begin_layout Itemize
Colonizza (
\begin_inset Formula $c_{2}$
\end_inset

) e' l'occupazione di una casella vuota adiacente a una occupata da una
 pedina del proprio colore
\end_layout

\end_deeper
\begin_layout Itemize
Priorita' delle mosse: 
\begin_inset Formula $c_{1}>c_{2}$
\end_inset

: quando e' possibile fare una conquista e' obbligatorio procedere in tale
 modo.
 Se invece, come a volte si verifica nelle fasi iniziali del gioco a giocatori
 separati fra loro, i giocatori sono impossibilitati a conquistare, allora
 si puo' procedere con una mossa di colonizzazione;
\end_layout

\begin_layout Itemize
Il giocatore che non puo' effettuare ne' conquiste ne' colonizzazioni e'
 costretto a cedere il proprio turno di gioco;
\end_layout

\begin_layout Itemize
Quando nessun giocatore potra' effettuare ulteriori mosse, il gioco si dira'
 terminato
\end_layout

\begin_deeper
\begin_layout Itemize
Il vincitore e' colui che avra' collezionato il maggior numero di pedine
 del proprio colore
\end_layout

\begin_layout Itemize
Nel caso in cui il numero maggiore di pendine veng acollezionato da due
 o piu' giocatori, allora il gioco terminera' con un pareggio
\end_layout

\end_deeper
\begin_layout Itemize
Per ogni giocatore che abbandona il gioco, le pedine possedute resteranno
 sul campo (diventando di colore grigio) e potranno essere conquistate in
 ossequio alle regole precedentemente introdotte;
\end_layout

\begin_layout Itemize
In caso di 
\begin_inset Formula $N-1$
\end_inset

 abbandoni il vincitore sara' il giocatore rimasto;
\end_layout

\begin_layout Itemize
Il vincitore paga da bere a tutti.
\end_layout

\begin_layout Standard
Sono necessarie alcune precisazioni:
\end_layout

\begin_layout Itemize
Una conquista puo' avere la conseguenza di far perdere tutte le pedine ad
 un giocatore, che sara' dichiarato sconfitto;
\end_layout

\begin_layout Itemize
La conquista riguarda esclusivamente le pedine imprigionate 
\emph on
direttamente
\emph default
 fra la pedina messa sulla scacchiera e la prima pedina del medesimo colore
 posta sulla stessa riga, colonna e/o diagonale;
\end_layout

\begin_layout Itemize
Questo insieme di regole non garantisce la fairness del gioco, poiche' la
 disposizione iniziale random potrebbe favorire alcuni giocatori a discapito
 di altri.
\end_layout

\begin_layout Subsection*
3.
 Scelte progettuali
\end_layout

\begin_layout Standard
Il sistema e' stato realizzato implementando due paradigmi di comunicazione:
 client-server e anello unidirezionale.
\end_layout

\begin_layout Standard
Il primo e' stato utilizzato unicamente per realizzare il servizio centralizzato
 di registrazione al gioco.
 Il secondo, invece, per realizzare le comunicazioni e il sistema di recovery
 dai guasti.
\end_layout

\begin_layout Standard
Come detto in precedenza, la registrazione e' stata realizzata sfruttando
 il modello client-server.
 Il server e' rappresentato dal servizio che raccoglie le richieste di partecipa
zione e provvede alla consegna della lista ordinata dei partecipanti una
 volta raggiunto il numero di giocatori stabilito.
 I client, di conseguenza, sono tutti coloro che intendono partecipare al
 gioco.
 Il server non e' un nodo a se stante, bensi' viene inizializzato assieme
 a una delle macchine partecipanti e il suo indirizzo dovra' quindi essere
 fornito a run-time.
 
\end_layout

\begin_layout Standard
Successivamente a questa fase il sistema funziona secondo il modello ad
 anello unidirezionale.
 Ogni nodo, infatti, puo' comunicare solo e soltanto con il suo successore
 nella lista e riceve messaggi esclusivamente dal suo predecessore.
 I nodi condividono uno stato globale, la othelliera, e annesse informazioni
 (caselle libere, caselle occupate, proprietari delle caselle, ecc).
 Affinche' lo stato globale sia sempre coerente, le operazioni di update
 sono consentite solo al giocatore che possiede il token in quel momento
 - il giocatore a cui tocca effettuare la mossa.
\begin_inset Newline newline
\end_inset

Il nodo che effettua una mossa inoltra un messaggio e attende che questo
 gli venga riconsegnato.
 Questo messaggio, effettuando un giro completo dell'anello, sara' visibile
 a tutti i nodi intermedi, i quali potranno leggerne e processarne il contenuto
 al fine di mantenere coerente lo stato globale.
 Al termine del turno di gioco il nodo passera' il token al suo successore.
\end_layout

\begin_layout Standard
Il sistema di recovery dai guasti è stato realizzato al fine di poter rilevare
 i crash attraverso l'esecuzione di due task: controllare che tutte le comunicaz
ioni da un nodo verso il successivo vengano effettuate con successo e verificare
 che lo stesso non si andato in crash anche in situazioni nelle quali non
 sono previste comunicazioni inerenti alle fasi di gioco.
\end_layout

\begin_layout Subsection*
4.
 Strategie implementative
\end_layout

\begin_layout Standard
Il gioco è state realizzato mediante l'impementazione di una rete ad anello
 unidirezionale: Tale scelta infatti rappresenta l'opzione più appropriate
 per la realizzazione di un gioco a turni, nonostante non sia allo stesso
 tempo la scelta più consona per la realizzazione di un sistema distribuito.
\end_layout

\begin_layout Standard
Affinchè i nodi possano comunicare seguendo tale paradigma, è necessario
 che condividano le informazione riguardo gli altri nodi del sistema: la
 classe PlayerList risponde a tale esigenza.
\end_layout

\begin_layout Standard
PlayerList rappresenta la lista ordinata dei giocatori, ed e' il frutto
 della fase di registrazione.
 Al suo interno sono presenti un numero variabile di oggetti di tipo Player.
 Ogni oggetto Player rappresenta la carta d'identita' del singolo nodo,
 poiche' al suo interno sono presenti tutti i dati che lo rappresentano.
 Infatti abbiamo informazioni presentazionali come il nome, di comunicazione
 come l'indirizzo IP e la porta, nonche' uno UUID per la sua identificazione
 univoca.
 All'interno di PlayerList, realizzata come estensione della classe LinkedList,
 sono presenti un numero considerevole di metodi di ricerca/aggiornamento
 della suddetta lista.
 Il modello di messaging prevede due famiglie di messaggi:
\end_layout

\begin_layout Itemize
Cambiamento dello stato di gioco: sono i messaggi di comunicazione della
 mossa e di passaggio del token.
\end_layout

\begin_layout Itemize
Gestione dei guasti: sono i messaggi di ping generati periodicamente e quello
 di notifica dei crash.
\end_layout

\begin_layout Standard
Cambiamento stato gioco.
\end_layout

\begin_layout Standard
Prima di introdurre le classi e i metodi che si occupano delle comunicazioni
 inerenti al cambimento dello stato di gioco e' necessario effettuare una
 breve introduzione su altre classi le quali hanno il compito di garantire
 la corretta operabilita' funzionale del sistema (anche dal punto di vista
 del regolamento).
 La prima di questa classi e' Othello: come si evince dal nome questa classe
 è fondamentale perchè si occupa della gestione della grafica, esegue il
 controllo di flusso, ossia quell'insieme di operazioni che consente di
 stabilire quando il giocatore puo' effetuare le proprie mosse, la verifica
 delle condizioni di fine gioco e la modifica dello stato (ossia la modifica
 dell'oggetto singleton Board) secondo le regole del gioco.
 Tali regole sono state separate dalla Board e sono state implementate nella
 classe BoardLogic in ossequio al principio di separazione della politica
 dai meccanismi che garantisce la giusta separazione fra la logica del gioco
 e lo stato condiviso.
 Al termine di tale processo all'interno di Othello verra' prima invocata
 la notifica del cambiamento dello stato e poi l'eventuale passaggio del
 token.
\end_layout

\begin_layout Standard
La classe all'interno della quale sono state implementate tutte le funzioni
 inerenti alla comunicazione del cambiamento dello stato, sono disponibili
 all'interno della classe Node.
 Questa classe è stata strutturata in maniera molto semplice e possiamo
 sostanzialmente distinguere tre operazioni principali
\end_layout

\begin_layout Itemize
Inizializzazione del nodo: Questo task viene svolto dal metodo initializeNode()
 e si tratta dell'inizializzazione del nodo con i dati relativi alle informazion
i del giocatore e della successiva attivazione dei metodi RMI della classe.
 Nel caso in cui il nodo in questione debba anche fungere da servizio di
 registrazione, tale servizio viene attivato in questo metodo
\end_layout

\begin_layout Itemize
Registrazione al gioco: Questo task viene svolto dal metodo registerToGame()
 e consiste in una interazione con il servizio di registrazione al fine
 di ottenere la lista ordinata dei giocatori.
 
\end_layout

\begin_layout Itemize
Comunicazione: Questo task viene svolto principalmente dal metodo broadcast()
 (deliver?????), il quale a seconda della tipologia di parametro, effettua
 la relativa gestione della comunicazione.
 Al fine di rendere più corretta la struttura delle direttive di comunicazione,
 sono stati previsti 3 metodi che nei fatti sfruttano broadcast(): startGame(),
 usata per condividere con tutti gli altri nodi lo stato iniziale, sendMove(),
 usata per comunicare la mossa effettuata e sendToken(), usata per passare
 il token al nodo successivo e quindi rendere operativo il cambio di turno.
\end_layout

\begin_layout Standard
Quanto descritto fin'ora non è sufficiente a completare il progetto poichè
 le specifiche impongono la gestione dei guasti di tipo crash.
 Di cio' si occupa la classe CrashManager.
 Questa classe e' stata pensata per potersi accorgere di un guasto in due
 differenti contesti operativi.
 Quello piu' scontato e triviale e' la rilevazione di tale tipologia di
 guasti in seguito alla cattura di una RemoteException in tutti i metodi
 della classe Node deputati alla comunicazione: verrà dunque catturato un
 errore di comunicazione con il nodo succcessivo.
 In tali metodi e' stata sempre utilizzata le seguente struttura:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void direttivaComunicazione(){
\end_layout

\begin_layout Plain Layout

	try {
\end_layout

\begin_layout Plain Layout

		//Invocazione direttiva RMI
\end_layout

\begin_layout Plain Layout

	} catch (RemoteException e) {
\end_layout

\begin_layout Plain Layout

		cm.repairAndBroadcastPlayerList();
\end_layout

\begin_layout Plain Layout

		this.direttivaComunicazione();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ossia ogni problema di comunicazione viene intercettato e gestito da parte
 di un oggetto cm di tipo CrashManager attraverso l'utilizzo del metodo
 repairAndBroadcastPlayerList().
 Tale metodo infatti effettua due semplici operazioni:
\end_layout

\begin_layout Itemize
Rimuove dalla PlayerList il suo successore
\end_layout

\begin_layout Itemize
Comunica l'identificativo del giocatore rimosso a tutti gli altri nodi attivi
 inviando un messaggio al nuovo successore
\end_layout

\begin_layout Standard
In questo modo abbiamo la garanzia che tutti i nodi condivideranno lo stesso
 nuovo anello di comunicazione poiche' ogni nodo alla ricezione di tale
 identificatore provvedera' alla rimozione dell'annesso nodo dalla PlayerList.
 Al termine di tale operazione la direttiva desiderata viene reinvocata
 ricorsivamente in modo tale da poter garantire la corretta operabilita'
 del sistema anche nel caso in cui il nuovo successore vada in crash.
\end_layout

\begin_layout Standard
Tuttavia tale strategia non e' sufficiente a garantire una gestione completa
 dei crash poiche' non consente in nessun modo di poter gestire un caso
 reale molto semplice: il regolamento del gioco non da' nessun limite temporale
 al giocatore che detiene il turno.
 Questa situazione dal punto di vista implementativo significa che (usando
 solo la soluzione descritta in precedenza) e' impossibile stabilire se
 il nodo che detiene il token e' vivo pur non effettuando comunicazioni
 o se e' andato in crash.
 Per gestire tale situazione e' stato implementato il metodo ping() la cui
 esecuzione a intervalli prestabiliti è data dall'uso dell'oggetto Timer
 all'interno di startTimedController().
 Una mancata risposta al ping() implicherà una gestione dei guasti effettuata
 con lo stesso modus operandi descritto in precedenza.
 Al fine di poter rendere completa la gestione dei crash, l'uso del ping
 e' stato esteso a tutti i nodi dell'anello, indipendentemente dal fatto
 che questi detengano il token.
\end_layout

\begin_layout Standard
Dal momento che i crash sono impredicibili, è assolutamente plausibile che
 un nodo possa andare in crash durante un operazione del CrashManager: per
 questo motivo anche le direttive di comunicazione inter-nodo della classe
 CrashManager utilizzano lo schema di codice descritto per i metodi di comunicaz
ione della classe Nodo, ossia viene aggiornata la PlayerList, viene comunicato
 l'aggiornamento da effettuare, e infine la direttiva viene reinvocata ricorsiva
mente.
\end_layout

\begin_layout Standard
Un ultima doverosa spiegazione del meccanismo di gestione dei crash riguarda
 l'assenza di assunzioni su intervalli di time-out: tale mancanza non è
 dovuta a dimenticanze, bensì alla precisa scelta di voler sfruttare il
 fatto che RMI fornisce nativamente tali feature, ivi compresa la configurazione
 manuale di tale intervallo.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Verificare intervallo di Timeout sull'applicazione
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
5.
 Diagrammi
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lemad85/Scaricati/anello.png
	display false
	scale 15

\end_inset


\end_layout

\begin_layout Subsection*
6.
 Conclusioni
\end_layout

\begin_layout Standard
Come espresso al capitolo 1 lo scopo era realizzare un gioco con almeno
 3 giocatori, con uno stato globale condiviso e che tollerasse 
\begin_inset Formula $N-1$
\end_inset

 guasti di tipo crash, attraverso l'utilizzo di RMI come paradigma di comunicazi
one.
 Si può affermare che il sistema realizzato rispetta le specifiche imposte
 per la realizzazione dell'applicazione.
 L'utilizzo di RMI ha facilitato la realizzazione di un modello di messaging
 molto semplice ma assolutamente efficace ai fini dei requisiti e alle regole
 del gioco.
 La flessibilità di RMI è stata un fattore determinante anche per quanto
 concerne la realizzazione del sistema di recovery dai crash.
 In questo contesto è stata riscontrata la difficoltà progettuale maggiore,
 poichè si è resa necessaria l'adozione di un oggetto di tipo Timer per
 realizzare un ping temporizzato che potesse essere eseguito in maniera
 indipendente dal resto del sistema.
 E' opportuno sottolineare che la difficoltà riscontrata è essenzialmente
 imputabile alle scarse esperienze precedenti in termini di programmazione
 a più thread in linguaggio Java.
\end_layout

\begin_layout Standard
I possibili sviluppi futuri dell'applicazione riguardano l'adozione della
 possibilità di poter effettuare nuove partite senza dover chiudere ogni
 volta l'applicazione.
 Inoltre sarebbe molto interessate implementare un sistema di locate automatico
 del server di registrazione.
 Dal punto di vista dell'interfaccia grafica si potrebbe dare la possibilità
 ai giocatori di poter scegliere il proprio colore o addirittura il proprio
 avatar.
\end_layout

\begin_layout Standard
Tuttavia questi aspetti sono a parere degli autori secondari rispetto al
 design architetturale, che soddisfa invece le speciche iniziali.
\end_layout

\end_body
\end_document
